## 01-3.마켓과 머신러닝
## 핵심포인트 정리
> - **특성**은 데이터를 표현하는 하나의 성질
- 머신러닝 알고리즘이 데이터를 찾는 과정을 훈련이라고 함. 사잇킷런에서는 fit () 메서드가 하는 역할
- k-최근접 이웃 알고리즘은 가장 간단한 머신러닝 알고리즘 중 하나. 사실 전체 데이터를 메모리에 가지고 있는 것이 전부
- 머신러닝 프로그램에서는 알고리즘이 구현된 객체를 모델이라고 부름.
- 정확도는 정확한 답을 몇 개 맞혔는지를 백분율로 나타낸 값. 사이킷런에서는 0~1 사이의 값으로 출력됨
정확도 = (정확히 맞힌 개수) / (전체 데이터 개수)

## 핵심 패키지와 함수
> - scatter()는 산점도를 그리는 맷플롯립 함수.
- scikit-learn
  - KNeighborsClassifier()는 k-최근접 이웃 분류 모델을 만드는 사이킷런 클래스.

## 실습 기록
  ![](https://velog.velcdn.com/images/kwak00912/post/7633d936-af97-4198-9dc8-f373b1a5b616/image.png)

## 실습 코드
https://colab.research.google.com/drive/1gEymib562GJc5_Ua52YA9xMFUTu-FaAc?usp=drive_link

----

## 02-1.훈련 세트와 데이터 세트
## 핵심포인트 정리
> - **지도학습**은 입력과 타깃을 전달하여 모델을 훈련한 다음 새로운 데이터를 예측하는 데 활용
- **비지도학습**은 타깃 데이터가 없음. 입력데이터에서 어떤 특징을 찾는데 주로 사용
- **훈련 세트** 모델 훈련할때 사용하는 데이터. 훈련 세트가 클수록 좋음
- **테스트 세트** 전체 데이터에서 20~30%를 테스트 세트로 사용하는 경우 많음. 데이터 양이 많다면 1%도 사용가능.

## 핵심 패키지와 함수
> 
- **seed()**는 넘파이에서 난수를 생성하기 위한 정수 초깃값 지정.
- **arange()**는 일정한 간격의 정수 또는 실수 배열 만들기.

```python
print(np.arange(4))
```
>[0, 1, 2, 3]

## 확인문제
> 
1. 지도학습
2. 훈련세트와 테스트 세트가 잘못 만들어져 전체 데이터를 대표하지 못하는 현상
>> 샘플링 편향
3. 사이킷런은 입력 데이터(배열)가 어덯게 구성되어 있을 것으로 기대?
>> 2) 행: 샘플, 열: 특성

## 실습한 부분
![](https://velog.velcdn.com/images/kwak00912/post/a4e99f8d-1ec7-4033-9cb8-a15f7a8fe127/image.png)

## 실습 코드
https://colab.research.google.com/drive/17QX_O5dzEA2jVOPVxOaSZ7uzrs4yzWF_?usp=drive_link

----

## 02-2.데이터 전처리
## 핵심 포인트
>
- **데이터 전처리**는 머신러닝 모델에 훈련 데이터를 주입하기 전에 가공하는 단계
- **표준점수**는 훈련 세트의 스케일을 바꾸는 대표적인 방법. 표준점수를 얻으려면 특성의 평균을 빼고 표준편차로 나눔. 
- **브로드캐스팅**은 크기가 다른 넘파이 배열에서 자동으로 사칙 연산을 모든 행이나 열로 확장하여 수행하는 것

## 핵심 패키지와 함수
> **Scikit-learn**
--
- **train_test_split()** 은 훈련 데이터를 훈련 세트와 테스트 세트로 나누는 함수. 여러개의 배열을 전달할 수 있음. 기본값은 0.25(25%)
shuffle 매개변수로 훈련 세트와 테스트 세트로 나누기 전에 무작위로 섞을지 여부를 결정. stratify 매개변수에 클래스 레이블이 담긴 배열(일반적으로 타깃 데이터)을 전달하면 훈련 세트와 테스트 세트 나눔
- **kneighbors()** 는 k-최근접 이웃 객체의 메서드. 입력한 데이터에 가장 가까운 이웃을 찾아 거리와 이웃 샘플의 인덱스를 반환함

## 느낀점
>
- 데이터 분석에 있어 데이터 전처리가 정말 중요하다고 생각하는데, 관련하여 여러 가지를 깨닳을 수 있는 학습이었던 것 같음.
- 물론 모든 과정, 함수를 다 외우지는 못했으나 최대한 이해해보려고 노력했음
- 여기 데이터 뿐 아니라 직접 데이터를 가져와서 해보는 것도 재밌지 않을까 하는 생각도 들긴 하는데 하긴 할지 모르겠음
- 표준점수로 전처리 하는 방법을 잘 사용할 수 있지 않을까 생각함


![distance가 저렇게 나오는 이유는](https://velog.velcdn.com/images/kwak00912/post/c738e117-489e-420e-81c2-f4bda16e26d3/image.png)
- 거리가 왜 저렇게 나오는 지 처음엔 이해를 못했는데 조금 생각해보니 단위 때문이란 것을 알 수 있었음.

![전처리 후 예측이 생각대로 되는 모습](https://velog.velcdn.com/images/kwak00912/post/15701a4c-65a0-4823-be95-f7bbbb8888f0/image.png)

- 간단한 전처리 작업 후 제대로 예측이 되는 모습

## 실습 코드
https://colab.research.google.com/drive/1qCH6pd0PrsTJgwWBTWPSieDNTEyJLur0?usp=drive_link

----

## 03-1.k-최근접 이웃 회귀
## 핵심 포인트
> 
- 회귀는 임의의 수치를 예측하는 문제
- k-최근접 이웃회기는 k-최근접 이웃 알고리즘을 사용해 회귀 문제를 푸는 것. 가장 가까운 이웃 샘플을 찾고 이 샘플들의 타깃값을 평균하여 예측
- 결정계수(R^2)는 대표적인 회귀 문제의 성능 측정 도구
- 과대적합: 모델 훈련 세트 성능이 테스트 세트 성능보다 훨씬 높을 때
- 과소적합: 훈련 세트와 테스트 세트 성능이 모두 동일하게 낮거나, 테스트 세트 성능이 오히려 더 높을 때 일어남.

## 핵심 패키지와 함수
>
**scikit-learn**
- KNeighborsRegressor 
  - k-최근접 이웃 회귀 모델을 만든느 사이킷럿 클래스. 
- mean_absolute_error(): 회귀 모델의 평균 절댓값 오차를 계산
>
**numpy**
- reshpae(): 배열의 크기를 바꾼느 메서드. 바꾸고자 하는 배열의 크기를 매개변수로 전달함. 바꾸지 전후의 배열 원소 개수는 동일해야 함.

## 실습한 부분
![](https://velog.velcdn.com/images/kwak00912/post/378578e6-e95a-433c-9a07-151f01b244ed/image.png)

## 실습 코드
https://colab.research.google.com/drive/1b7vtXcviyPKel1e6db0x1whByrjzLo0D?usp=drive_link

----

## 03-2.선형 회귀
## 핵심 포인트
> 
- **선형 회귀**는 특성과 타깃 사이의 관계를 가장 잘 나타내는 선형 방정식을 찾음. 특성이 하나이면 직선 방정식이 됨
- 선혀 회귀가 찾은 특성과 타깃 사이의 관계는 선형 방정식의 계수 또는 가중치에 저장
- **모델 파라미터** 는 선형 회귀가 찾은 가중치처럼 머신러닝 모델이 특성에서 학습한 파라미터를 말함
- **다항 회귀** 다항식을 사용하여 특성과 타깃 사이의 관계를 나타냄

## 핵심 패키지와 함수
>
**scikit-learn**
- **LinearRegression**은 사이킷런의 선형 회귀 클래스

## 핵심 코드
```python
# 구간별 직선을 그리기 위해 15에서 49까지 정수 배열을 만듭니다
point = np.arange(15, 50)
# 훈련 세트의 산점도를 그립니다
plt.scatter(train_input, train_target)
# 15에서 49까지 2차 방정식 그래프를 그립니다
plt.plot(point, 1.01*point**2 - 21.6*point + 116.05)
# 50cm 농어 데이터
plt.scatter([50], [1574], marker='^')
plt.xlabel('length')
plt.ylabel('weight')
plt.show()
```
![](https://velog.velcdn.com/images/kwak00912/post/c1739782-3105-4688-b089-38f4234c8de9/image.png)

## 핵심 코드
https://colab.research.google.com/drive/1fdH4hEGv-wm2pfctvUKZ8qX39gmb_U2X?usp=drive_link
